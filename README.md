В лабораторной работе требуется определить классы для матриц
специального вида на языках C# и С++. Классы содержат метод для решения
системы линейных алгебраических уравнений, который учитывает специфику
матрицы. Эти классы используются для сравнения времени выполнения управляемого
кода C# и неуправляемого кода C++. Код С++ компилируется в
DLL-библиотеку. Код C# вызывает методы из DLL-библиотеки С++ с помощью
сервиса PInvoke. Для сохранения в файле результатов тестирования времени
выполнения кодов С# и C++ используется сериализация.
Варианты отличаются типом матриц специального вида, для которых
определяются классы C# и С++.

Класс Matrix
Матрица специального вида полностью определяется либо одной строкой
(циркулянтная и симметричная теплицева), либо одной строкой и одним
столбцом (теплицева и ганкелева), либо тремя диагоналями (трехдиагональная
матрица).
Память для хранения матрицы распределяется в конструкторе. Порядок
матрицы передается как параметр конструктора.
В памяти хранится не вся полная матрица, а только информация, необходимая
для того, чтобы задать полную матрицу:
 для циркулянтных и теплицевых симметричных матриц в памяти хранится
только одна строка;
 для теплицевых и ганкелевых матриц в памяти хранятся только столбец и
строка;
 для трехдиагональных матриц в памяти хранятся только диагонали.
За счет этого экономится память для хранения матриц. Полная матрица
содержит 2 n элементов, в то время как для рассматриваемых матриц
специального вида порядка n
в зависимости от типа матрицы достаточно хранить n , 2n или 3n элементов.
Для элементов матриц лучше использовать тип double, так как арифметические
операции с операндами типа float и double выполняются с одинаковой
скоростью, но у типа double шире диапазон значений и выше точность при
хранении. Длина типа double гарантирует 15-16 десятичных цифр, длина типа
float только 7 десятичных цифр. Тип float по сравнению с double имеет
преимущество только в экономии памяти при хранении данных.
В классе C++ должны быть определены
 конструктор Matrix (int n) для инициализации матрицы по умолчанию;
 конструктор для пользовательской инициализации матрицы;
 конструктор копирования с прототипом Matrix (const Matrix &);
 деструктор;
 операция присваивания c прототипом Matrix& operator=(const Matrix &);
 метод для решения системы линейных уравнений.
В коде С++ не должно быть утечки памяти, т.е. вся память, выделенная
динамически с помощью оператора new, должна быть освобождена с
помощью оператора delete.
Метод для решения системы линейных уравнений должен принимать как
параметр массив элементов типа double, содержащий вектор правой части. В
реализации метода на C++ вектор решения также необходимо передать через
параметр, в этом случае память для него будет и распределяться, и
освобождаться в вызываемом методе. При передаче решения через
возвращаемое значение метода память приходится распределять в
вызываемом методе, а освобождать в вызывающем. В реализации этого
метода на C# вектор решения можно передать как возвращаемое значение, так
как память освобождается сборщиком мусора.
В классе C# должны быть определены
 конструктор Matrix ( int n) для инициализации матрицы по умолчанию;
 конструктор для пользовательской инициализации матрицы;
 метод для решения системы линейных уравнений;
 перегруженная версия виртуального метода ToString().
Конструктор Matrix(int n) используется для автоматической генерации матрицы
порядка n при сравнении скорости выполнения кодов C# и C++. Так как время
решения системы линейных уравнений определяется только порядком
матрицы и не зависит от того, для какой конкретной матрицы и правой части
решается система, в конструкторе для автоматической генерации матрицу надо
задать так, чтобы при решении системы уравнений не возникало проблем с
плохой обусловленностью матрицы. Для этого достаточно на главной
диагонали матрицы задать элементы, которые по модулю значительно больше
внедиагональных элементов. Не следует использовать методы случайной
генерации элементов матрицы, так как этот процесс значительно медленнее,
чем простое присваивание значений, кроме того, чтобы получить хорошо
обусловленную матрицу, придется специально корректировать значения.
В приложении 2 приведены формулы для решения системы линейных
уравнений с теплицевыми матрицами, которые для системы порядка
n требуют 2n арифметических операций. Для этого алгоритма время решения
системы линейных уравнений должно возрастать в 4 раза при увеличении
порядка матрицы в 2 раза. Это соотношение выполняется только для матриц
достаточно большого порядка, так как для матриц малого порядка накладные
расходы на вызов метода, распределение и освобождение памяти в методе
решения системы линейных уравнений будут сравнимы со временем
выполнения арифметических операций.
В методе для решения системы линейных уравнений не должна
распределяться память для полной матрицы, так как обратная матрица
определяется либо двумя векторами x и y (теплицева и ганкелева матрицы),
либо одним вектором (теплицева симметричная и циркулянтная).
Для трехдиагональных матриц зависимость времени решения от порядка
матрицы – линейная, это значит, что для матриц большого порядка при
увеличении порядка матрицы в 2 раза, время решения системы линейных
уравнений также возрастает в 2 раза.
Вызов неуправляемого кода C++ из кода C#
Код С++ надо скомпилировать в DLL-библиотеку, содержащую две
глобальные экспортируемые функции, которые вызываются из кода C#.
Первая глобальная экспортируемая функция С++ используется только для
сравнения времени выполнения кода C# и кода С++. Эта функция из кода C#
получает через параметры только два целочисленных значения - порядок
матрицы и число повторов. Так как для матриц небольшого порядка решение
системы выполняется быстро и точности системного таймера не хватает для его
измерения, решение одной и той же системы линейных уравнений
выполняется несколько раз, число повторов задается в коде C# и передается
через параметр глобальной экспортируемой функции.
В первой глобальной экспортируемой функции создается объект типа Matrix и
с помощью конструктора Matrix(int n) генерируется матрица заданного
порядка. В цикле заданное число раз решается система уравнений для одной и
той же матрицы с одной и той же правой часью и измеряется время
выполнения этого цикла. Правую часть для системы линейных уравнений
нужно инициализировать вне цикла.
Для измерения времени выполнения кода С++ можно использовать функцию
clock(). Время выполнения кода C++ возвращается в вызывающий код C# либо
через параметр глобальной экспортируемой функции, либо как возвращаемое
значение.
Вторая глобальная экспортируемая функция С++ получает из кода C# данные,
которые определяют матрицу и правую часть. В коде С++ решается система
линейных уравнений, решение возвращается в код C# также через параметр
этой глобальной экспортируемой функции.
Самый простой способ обмена данными между кодами C# и C++ – обмен
данными в виде массивов с элементами типа double через параметры
экспортируемой функции.
Для того, чтобы отделить интерфейсную часть кода C# от вычислительной, в
коде на С# надо определить метод, который через параметры получает
порядок матрицы и число повторов, автоматически генерирует матрицу и
правую часть, выполняет вычисления и возвращает время выполнения цикла
на C#.
Оба проекта (для C# и C++) надо разместить в одном решении (solution). В коде
C# в атрибуте DllImport надо указать относительный путь к файлу с
 DLLбиблиотекой, скомпилированной из исходного кода C++. В этом случае при
копировании решения(solution) в другой каталог не потребуется вносить
изменения в атрибут DllImport, а при перекомпиляции C++-проекта файл с
DLLбиблиотекой не надо будет вручную копировать в текущий каталог проекта C#.
Сериализация
В коде C# определить тип TimeItem (класс или структуру) для хранения
времени выполнения кода для одной пары значений порядка матрицы и числа
повторов и класс TimesList для хранения всей информации.
Тип TimeItem должен иметь поля, в которых хранятся
 порядок матрицы;
 число повторов;
 время выполнения цикла в коде на C#;
 время выполнения цикла в коде на C++;
 коэффициент, равный отношению времени выполнения кода на C# и кода
на C++.
В классе TimesList должны быть определены
 закрытое поле типа List<TimeItem> - список объектов типа TimeItem;
 открытый метод Add(TimeItem), добавляющий новый объект TimeItem к
списку;
 открытый метод Save(string filename) для сохранения списка List<TimeItem>
в файле с использованием сериализации;
 открытый метод Load(string filename) для восстановления списка
List<TimeItem> из файла с использованием сериализации.
Когда пользователь завершает работу приложения, список List<TimeItem> из
объекта TimesList сохраняется в файле с именем, которое пользователь ввел в
начале работы приложения.
В методе Main()
1. Проверить, что метод решения системы линейных уравнений работает
правильно. Для этого надо программно задать матрицу 3-го порядка и
правую часть. В вариантах 1-4 необходимо задать матрицу с
несовпадающими элементами в строках и столбцах, которые ее
определяют. Диагонали трехдиагональной матрицы также должны
содержать несовпадающие элементы. Решить систему линейных
уравнений и вывести матрицу, правую часть и решение, полученное в
коде C#.
2. Передать в код C++ через параметры глобальной экспортируемой
функции данные, которые определяют матрицу и правую часть. Решить
систему линейных уравнений, решение передать в код C# и вывести
полученное решение.
3. Создать один объект типа TimesList и предложить пользователю ввести
имя файла:
 если файла с заданным именем нет, то в объекте TimesList
создается пустая коллекция List<TimeItem>;
 если файл уже существует, то приложение
 открывает файл;
 инициализирует список List<TimeItem> объекта TimesList
данными из файла, выполняя десериализацию;
 закрывает файл;
 выводит все данные на экран.
4. После того, как пользователь ввел имя файла, он получает приглашение
ввести порядок матрицы и число повторов или завершить работу
приложения.
5. Если пользователь ввел порядок матрицы и число повторов,
 приложение выполняет вычисления на C#;
 вызывает экспортируемую функцию из DLL-библиотеки С++;
 сохраняет результаты в объекте TimeItem;
 добавляет объект TimeItem в список List<TimeItem> объекта
TimesList;
 затем пользователь снова получает приглашение ввести новые
значения порядка матрицы и числа повторов или завершить работу
приложения.
6. Когда пользователь завершает работу приложения
 выводится вся коллекция из объекта TimesList;
 коллекция из объекта TimesList сохраняется c использованием
сериализации в файле с именем, которое пользователь ввел в
начале работы приложения.
7. Весь вывод должен быть подписан. Элементы списка имеют тип
TimeItem, который содержит пять полей. Можно вывести список в виде
таблицы, в которой первая строка содержит заголовки с описанием
данных, размещенных в столбце, и каждый из элементов списка вывести
как строку таблицы.
8. Все исключения, которые могут возникнуть при работе приложения, в
том числе из-за ошибок при вводе данных, должны быть обработаны. В
частности, код, в котором выполняется сериализация/десериализация и
код, вызывающий глобальные экспортируемые функции из DLLбиблиотеки C++,
должен находиться в блоках try/catch.
